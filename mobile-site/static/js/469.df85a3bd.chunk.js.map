{"version":3,"file":"static/js/469.df85a3bd.chunk.js","mappings":"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","sources":["../node_modules/embla-carousel/src/components/utils.ts","../node_modules/embla-carousel/src/components/Alignment.ts","../node_modules/embla-carousel/src/components/Limit.ts","../node_modules/embla-carousel/src/components/Counter.ts","../node_modules/embla-carousel/src/components/EventStore.ts","../node_modules/embla-carousel/src/components/Vector1d.ts","../node_modules/embla-carousel/src/components/DragHandler.ts","../node_modules/embla-carousel/src/components/ScrollBody.ts","../node_modules/embla-carousel/src/components/ScrollBounds.ts","../node_modules/embla-carousel/src/components/ScrollContain.ts","../node_modules/embla-carousel/src/components/ScrollLooper.ts","../node_modules/embla-carousel/src/components/ScrollProgress.ts","../node_modules/embla-carousel/src/components/ScrollTarget.ts","../node_modules/embla-carousel/src/components/Translate.ts","../node_modules/embla-carousel/src/components/SlideLooper.ts","../node_modules/embla-carousel/src/components/SlidesInView.ts","../node_modules/embla-carousel/src/components/SlidesToScroll.ts","../node_modules/embla-carousel/src/components/Engine.ts","../node_modules/embla-carousel/src/components/Direction.ts","../node_modules/embla-carousel/src/components/Axis.ts","../node_modules/embla-carousel/src/components/PercentOfView.ts","../node_modules/embla-carousel/src/components/SlideSizes.ts","../node_modules/embla-carousel/src/components/ScrollSnaps.ts","../node_modules/embla-carousel/src/components/ScrollLimit.ts","../node_modules/embla-carousel/src/components/Animation.ts","../node_modules/embla-carousel/src/components/ScrollTo.ts","../node_modules/embla-carousel/src/components/DragTracker.ts","../node_modules/embla-carousel/src/components/Options.ts","../node_modules/embla-carousel/src/components/OptionsHandler.ts","../node_modules/embla-carousel/src/components/index.ts","../node_modules/embla-carousel/src/components/PluginsHandler.ts","../node_modules/embla-carousel/src/components/EventHandler.ts","../node_modules/embla-carousel-react/src/components/utils.ts","../node_modules/embla-carousel-react/src/components/index.ts","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js"],"sourcesContent":["export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function isArray(subject: unknown): subject is Record<number, unknown> {\n  return Array.isArray(subject)\n}\n\nexport function isRecord(\n  subject: unknown,\n): subject is Record<string | number, unknown> {\n  return isObject(subject) || isArray(subject)\n}\n\nexport function mathAbs(n: number): number {\n  return Math.abs(n)\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / mathAbs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return mathAbs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA))\n  return mathAbs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function objectKeys<Type>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function objectsAreEqual(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): boolean {\n  const objectAKeys = objectKeys(objectA)\n  const objectBKeys = objectKeys(objectB)\n\n  if (objectAKeys.length !== objectBKeys.length) return false\n\n  return objectAKeys.every((key) => {\n    const valueA = objectA[key]\n    const valueB = objectB[key]\n    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB\n    return objectsAreEqual(valueA, valueB)\n  })\n}\n","import { isNumber } from './utils'\n\nexport type AlignmentOptionType = 'start' | 'center' | 'end' | number\n\nexport type AlignmentType = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number,\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (isNumber(align)) return percent()\n    return predefined[align](n)\n  }\n\n  const self: AlignmentType = {\n    measure,\n  }\n  return self\n}\n","import { mathAbs } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number, max: number): LimitType {\n  const length = mathAbs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n  min: number\n  max: number\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean,\n): CounterType {\n  const { min, constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    add,\n    clone,\n    get,\n    set,\n    min,\n    max,\n  }\n  return self\n}\n","type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType,\n  ) => EventStoreType\n  removeAll: () => EventStoreType\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = { passive: true },\n  ): EventStoreType {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => node.removeEventListener(type, handler, options))\n    return self\n  }\n\n  function removeAll(): EventStoreType {\n    listeners = listeners.filter((remove) => remove())\n    return self\n  }\n\n  const self: EventStoreType = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","import { isNumber } from './utils'\n\nexport type Vector1DType = {\n  get: () => number\n  set: (v: Vector1DType | number) => Vector1DType\n  add: (v: Vector1DType | number) => Vector1DType\n  subtract: (v: Vector1DType | number) => Vector1DType\n  multiply: (n: number) => Vector1DType\n  divide: (n: number) => Vector1DType\n  normalize: () => Vector1DType\n}\n\nexport function Vector1D(value: number): Vector1DType {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1DType | number): Vector1DType {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1DType | number): Vector1DType {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1DType | number): Vector1DType {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1DType {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1DType {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1DType {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1DType | number): number {\n    return isNumber(n) ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { DirectionType } from './Direction'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { deltaAbs, factorAbs, mathAbs, mathSign } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type DragHandlerType = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  target: Vector1DType,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  loop: boolean,\n  dragFree: boolean,\n  skipSnaps: boolean,\n): DragHandlerType {\n  const { cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const nonPassiveEvent = { passive: false }\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const dragThreshold = percentOfView.measure(20)\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseSpeed = dragFree ? 5 : 16\n  const baseMass = 1\n\n  let startScroll = 0\n  let startCross = 0\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = rootNode\n    activationEvents\n      .add(node, 'dragstart', (evt) => evt.preventDefault(), nonPassiveEvent)\n      .add(node, 'touchmove', () => undefined, nonPassiveEvent)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click, true)\n  }\n\n  function addInteractionEvents(): void {\n    const node = isMouse ? document : rootNode\n    interactionEvents\n      .add(node, 'touchmove', move, nonPassiveEvent)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move, nonPassiveEvent)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.clone().add(mathSign(force) * -1)\n    const isEdge = next.get() === index.min || next.get() === index.max\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || mathAbs(force) < dragThreshold) return baseForce\n    if (!loop && isEdge) return baseForce * 0.4\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    isMouse = !dragTracker.isTouchEvent(evt)\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n    if (isFocusNode(evt.target as Element)) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n    eventHandler.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n  }\n\n  function move(evt: PointerEventType): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      const lastScroll = dragTracker.readPoint(evt)\n      const lastCross = dragTracker.readPoint(evt, crossAxis)\n      const diffScroll = deltaAbs(lastScroll, startScroll)\n      const diffCross = deltaAbs(lastCross, startCross)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.apply(diff))\n    evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction.apply(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n    const isVigorous = targetChanged && forceFactor > 0.75\n    const isBelowThreshold = mathAbs(rawForce) < dragThreshold\n    const speed = isVigorous ? 10 : baseSpeed\n    const mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    eventHandler.emit('pointerUp')\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) {\n      evt.stopPropagation()\n      evt.preventDefault()\n    }\n  }\n\n  // DEPRECATED - Remove in v8 because handled automatically\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n","import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  seek: (target: Vector1DType) => ScrollBodyType\n  settle: (target: Vector1DType) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBodyType\n  useBaseSpeed: () => ScrollBodyType\n  useMass: (n: number) => ScrollBodyType\n  useSpeed: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  baseSpeed: number,\n  baseMass: number,\n): ScrollBodyType {\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(force: Vector1DType): void {\n    force.divide(mass)\n    acceleration.add(force)\n  }\n\n  function seek(target: Vector1DType): ScrollBodyType {\n    attraction.set(target).subtract(location)\n    const magnitude = map(attraction.get(), 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction.normalize().multiply(magnitude).subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(target: Vector1DType): boolean {\n    const diff = target.get() - location.get()\n    const hasSettled = !roundToTwoDecimals(diff)\n    if (hasSettled) location.set(target)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useBaseSpeed(): ScrollBodyType {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBodyType {\n    return useMass(baseMass)\n  }\n\n  function useSpeed(n: number): ScrollBodyType {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBodyType {\n    mass = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType,\n): ScrollBoundsType {\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const maxFriction = 0.85\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const diffToTarget = target.get() - location.get()\n    const friction = Math.min(diffToEdge / edgeOffsetTolerance, maxFriction)\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollContainOptionType = '' | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, snapsAligned[0])\n  const snapsBounded = snapsAligned.map(scrollBounds.constrain)\n  const snapsContained = measureContained()\n\n  function findDuplicates(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = findDuplicates()\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[],\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length: scrollLength } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return currentLocation / -scrollLength\n  }\n\n  const self: ScrollProgressType = {\n    get,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType,\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const targets = [target, target + contentSize, target - contentSize]\n\n    if (!loop) return targets[0]\n    if (!direction) return minDistance(targets)\n\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction)\n    return minDistance(matchingTargets)\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { DirectionType } from './Direction'\nimport { Vector1DType } from './Vector1d'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (vector: Vector1DType) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement,\n): TranslateType {\n  const translate = axis.scroll === 'x' ? x : y\n  const containerStyle = container.style\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}px,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}px,0px)`\n  }\n\n  function to(target: Vector1DType): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.apply(target.get()))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    if (disabled) return\n    containerStyle.transform = ''\n    if (!container.getAttribute('style')) container.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInViewType } from './SlidesInView'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { Translate, TranslateType } from './Translate'\nimport { DirectionType } from './Direction'\n\ntype EdgeType = 'start' | 'end'\n\ntype LoopPointType = {\n  index: number\n  translate: TranslateType\n  location: Vector1DType\n  target: () => Vector1DType\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  direction: DirectionType,\n  viewSize: number,\n  contentSize: number,\n  slideSizesWithGaps: number[],\n  scrollSnaps: number[],\n  slidesInView: SlidesInViewType,\n  scroll: Vector1DType,\n  slides: HTMLElement[],\n): SlideLooperType {\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(indexes: number[], edge: EdgeType): LoopPointType[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds([offset])\n\n    return indexes.map((index) => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter((b) => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const shift = Vector1D(-1)\n      const location = Vector1D(-1)\n      const translate = Translate(axis, direction, slides[index])\n      const target = () => shift.set(scroll.get() > point ? initial : altered)\n      return { index, location, translate, target }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, location } = loopPoint\n      const shift = target()\n      if (shift.get() === location.get()) return\n      if (shift.get() === 0) translate.clear()\n      else translate.to(shift)\n      location.set(shift)\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear())\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\n\nexport type SlideBoundType = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInViewType = {\n  check: (location: number, bounds?: SlideBoundType[]) => number[]\n  findSlideBounds: (offsets?: number[], threshold?: number) => SlideBoundType[]\n}\n\nexport function SlidesInView(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  limit: LimitType,\n  loop: boolean,\n  inViewThreshold: number,\n): SlidesInViewType {\n  const { removeOffset, constrain } = limit\n  const roundingSafety = 0.5\n  const cachedOffsets = loop ? [0, contentSize, -contentSize] : [0]\n  const cachedBounds = findSlideBounds(cachedOffsets, inViewThreshold)\n\n  function findSlideThresholds(threshold?: number): number[] {\n    const slideThreshold = threshold || 0\n\n    return slideSizes.map((slideSize) => {\n      const thresholdLimit = Limit(roundingSafety, slideSize - roundingSafety)\n      return thresholdLimit.constrain(slideSize * slideThreshold)\n    })\n  }\n\n  function findSlideBounds(\n    offsets?: number[],\n    threshold?: number,\n  ): SlideBoundType[] {\n    const slideOffsets = offsets || cachedOffsets\n    const slideThresholds = findSlideThresholds(threshold)\n\n    return slideOffsets.reduce((list: SlideBoundType[], offset) => {\n      const bounds = snaps.map((snap, index) => ({\n        start: snap - slideSizes[index] + slideThresholds[index] + offset,\n        end: snap + viewSize - slideThresholds[index] + offset,\n        index,\n      }))\n      return list.concat(bounds)\n    }, [])\n  }\n\n  function check(location: number, bounds?: SlideBoundType[]): number[] {\n    const limitedLocation = loop ? removeOffset(location) : constrain(location)\n    const slideBounds = bounds || cachedBounds\n\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < limitedLocation && end > limitedLocation\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInViewType = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n","import { arrayKeys, arrayLast, isNumber } from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  viewSize: number,\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollOptionType,\n): SlidesToScrollType {\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    return arrayKeys(array)\n      .reduce((groupSizes: number[], i) => {\n        const chunk = slideSizesWithGaps.slice(arrayLast(groupSizes), i + 1)\n        const chunkSize = chunk.reduce((a, s) => a + s, 0)\n        return !i || chunkSize > viewSize ? groupSizes.concat(i) : groupSizes\n      }, [])\n      .map((start, i, groupSizes) => array.slice(start, groupSizes[i + 1]))\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides,\n  }\n  return self\n}\n","import { Alignment } from './Alignment'\nimport { Animation, AnimationType } from './Animation'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { Direction, DirectionType } from './Direction'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type EngineType = {\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: Vector1DType\n  translate: TranslateType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  containerRect: DOMRect\n  slideRects: DOMRect[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  eventHandler: EventHandlerType,\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n  } = options\n\n  // Measurements\n  const containerRect = container.getBoundingClientRect()\n  const slideRects = slides.map((slide) => slide.getBoundingClientRect())\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const viewSize = axis.measureSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && containScroll !== ''\n  const readEdgeGap = loop || containScroll !== ''\n  const { slideSizes, slideSizesWithGaps } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    readEdgeGap,\n  )\n  const slidesToScroll = SlidesToScroll(\n    viewSize,\n    slideSizesWithGaps,\n    groupSlides,\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slideSizesWithGaps,\n    slidesToScroll,\n    containSnaps,\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Draw\n  const update = (): void => {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown())\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      eventHandler.emit('settle')\n    }\n    if (!settled) {\n      eventHandler.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction())\n      engine.slideLooper.loop()\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(location, speed, 1)\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target,\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    eventHandler,\n  )\n  const slidesInView = SlidesInView(\n    viewSize,\n    contentSize,\n    slideSizes,\n    snaps,\n    limit,\n    loop,\n    inViewThreshold,\n  )\n\n  // DragHandler\n  const dragHandler = DragHandler(\n    axis,\n    direction,\n    root,\n    target,\n    DragTracker(axis),\n    location,\n    animation,\n    scrollTo,\n    scrollBody,\n    scrollTarget,\n    index,\n    eventHandler,\n    percentOfView,\n    loop,\n    dragFree,\n    skipSnaps,\n  )\n\n  // Engine\n  const engine: EngineType = {\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    eventStore: EventStore(),\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      location,\n      target,\n      scrollBody,\n      percentOfView,\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, location, [\n      location,\n      target,\n    ]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      direction,\n      viewSize,\n      contentSize,\n      slideSizesWithGaps,\n      scrollSnaps,\n      slidesInView,\n      location,\n      slides,\n    ),\n    slidesToScroll,\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate(axis, direction, container),\n  }\n  return engine\n}\n","export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  apply: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function apply(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    apply,\n  }\n  return self\n}\n","import { DirectionOptionType } from './Direction'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (rect: DOMRect) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  direction: DirectionOptionType,\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(rect: DOMRect): number {\n    const { width, height } = rect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return direction === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return direction === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n  }\n  return self\n}\n","export type PercentOfViewType = {\n  measure: (n: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(n: number): number {\n    return viewSize * (n / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slides: HTMLElement[],\n  readEdgeGap: boolean,\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const withEdgeGap = slideRects[0] && readEdgeGap\n  const startGap = measureStartGap()\n  const endGap = measureEndGap()\n  const slideSizes = slideRects.map(measureSize)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureStartGap(): number {\n    if (!withEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function measureEndGap(): number {\n    if (!withEdgeGap) return 0\n    const style = window.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(rects)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n  return self\n}\n","import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollType,\n  containScroll: boolean,\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const containedStartSnap = 0\n    const containedEndSnap = arrayLast(snaps) - arrayLast(slideSizesWithGaps)\n\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index, groupedSnaps) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(groupedSnaps)\n        if (containScroll && isFirst) return containedStartSnap\n        if (containScroll && isLast) return containedEndSnap\n        return snap + alignments[index]\n      })\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean,\n): ScrollLimitType {\n  const limit = measureLimit()\n\n  function measureLimit(): LimitType {\n    const startSnap = scrollSnaps[0]\n    const endSnap = arrayLast(scrollSnaps)\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit(min, max)\n  }\n\n  const self: ScrollLimitType = {\n    limit,\n  }\n  return self\n}\n","type CallbackType = () => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): AnimationType {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: CallbackType): CallbackType {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: AnimationType = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  eventHandler: EventHandlerType,\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetVector.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      eventHandler.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './Axis'\nimport { mathAbs } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  isTouchEvent: (evt: PointerEventType) => evt is TouchEvent\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(axis: AxisType): DragTrackerType {\n  const logInterval = 170\n\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function isTouchEvent(evt: PointerEventType): evt is TouchEvent {\n    return typeof TouchEvent !== 'undefined' && evt instanceof TouchEvent\n  }\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isTouchEvent(evt) ? evt.touches[0] : evt)[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    isTouchEvent,\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","import { AlignmentOptionType } from './Alignment'\nimport { AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { DirectionOptionType } from './Direction'\nimport { ScrollContainOptionType } from './ScrollContain'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  draggable: boolean\n  inViewThreshold: number\n  loop: boolean\n  skipSnaps: boolean\n  speed: number\n  startIndex: number\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  breakpoints: {},\n  dragFree: false,\n  draggable: true,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  speed: 10,\n  startIndex: 0,\n  active: true,\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsAreEqual, objectsMergeDeep } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  merge: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ) => TypeA\n  areEqual: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ) => boolean\n  atMedia: <Type extends OptionsType>(options: Type) => Type\n}\n\nexport function OptionsHandler(): OptionsHandlerType {\n  function merge<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function areEqual<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ): boolean {\n    const breakpointsA = JSON.stringify(objectKeys(optionsA.breakpoints || {}))\n    const breakpointsB = JSON.stringify(objectKeys(optionsB.breakpoints || {}))\n    if (breakpointsA !== breakpointsB) return false\n    return objectsAreEqual(optionsA, optionsB)\n  }\n\n  function atMedia<Type extends OptionsType>(options: Type): Type {\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => window.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce((a, mediaOption) => merge(a, mediaOption), {})\n\n    return merge(options, matchedMediaOptions)\n  }\n\n  const self: OptionsHandlerType = {\n    merge,\n    areEqual,\n    atMedia,\n  }\n  return self\n}\n","import { Engine, EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType } from './Options'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\nexport type EmblaNodesType = {\n  root: HTMLElement\n  container?: HTMLElement\n  slides?: HTMLElement[]\n}\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => EngineType\n  destroy: () => void\n  off: EventHandlerType['off']\n  on: EventHandlerType['on']\n  plugins: () => EmblaPluginsType\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  nodes: HTMLElement | EmblaNodesType,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[],\n): EmblaCarouselType {\n  const resizeHandlers = EventStore()\n  const optionsHandler = OptionsHandler()\n  const pluginsHandler = PluginsHandler()\n  const eventHandler = EventHandler()\n  const { on, off } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let optionsBase = optionsHandler.merge(\n    defaultOptions,\n    EmblaCarousel.globalOptions,\n  )\n  let options = optionsHandler.merge(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType\n  let rootSize = 0\n  let root: HTMLElement\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function storeElements(): void {\n    const providedContainer = 'container' in nodes && nodes.container\n    const providedSlides = 'slides' in nodes && nodes.slides\n\n    root = 'root' in nodes ? nodes.root : nodes\n    container = providedContainer || <HTMLElement>root.children[0]\n    slides = providedSlides || [].slice.call(container.children)\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    if (destroyed) return\n    storeElements()\n\n    optionsBase = optionsHandler.merge(optionsBase, withOptions)\n    options = optionsHandler.atMedia(optionsBase)\n    engine = Engine(root, container, slides, options, eventHandler)\n    rootSize = engine.axis.measureSize(root.getBoundingClientRect())\n\n    if (!options.active) return deActivate()\n\n    engine.translate.to(engine.location)\n    pluginList = withPlugins || pluginList\n    pluginApis = pluginsHandler.init(pluginList, self)\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        activate({ loop: false }, withPlugins)\n        optionsBase = optionsHandler.merge(optionsBase, { loop: true })\n        return\n      }\n      engine.slideLooper.loop()\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents()\n    }\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    const startIndex = selectedScrollSnap()\n    deActivate()\n    activate(optionsHandler.merge({ startIndex }, withOptions), withPlugins)\n    eventHandler.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.animation.stop()\n    engine.eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    pluginsHandler.destroy()\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    destroyed = true\n    resizeHandlers.removeAll()\n    deActivate()\n    eventHandler.emit('destroy')\n  }\n\n  function resize(): void {\n    const newOptions = optionsHandler.atMedia(optionsBase)\n    const optionsChanged = !optionsHandler.areEqual(newOptions, options)\n    const newRootSize = engine.axis.measureSize(root.getBoundingClientRect())\n    const rootSizeChanged = rootSize !== newRootSize\n    const pluginsChanged = pluginsHandler.haveChanged()\n\n    if (rootSizeChanged || optionsChanged || pluginsChanged) reActivate()\n    eventHandler.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter((index) => inView.indexOf(index) === -1)\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    if (!options.active || destroyed) return\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed)\n    engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), jump === true, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), jump === true, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n\n  activate(userOptions, userPlugins)\n  resizeHandlers.add(window, 'resize', resize)\n  setTimeout(() => eventHandler.emit('init'), 0)\n  return self\n}\n\nEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\nEmblaCarousel.optionsHandler = OptionsHandler\n\nexport default EmblaCarousel\n","import { EmblaCarouselType } from '.'\nimport { OptionsHandler } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\ntype PluginChangedHandlerType = () => boolean\n\nexport type PluginsHandlerType = {\n  init: (\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ) => EmblaPluginsType\n  destroy: () => void\n  haveChanged: PluginChangedHandlerType\n}\n\nexport function PluginsHandler(): PluginsHandlerType {\n  const { atMedia, areEqual } = OptionsHandler()\n  let activePlugins: EmblaPluginType[] = []\n  let pluginsChanged: PluginChangedHandlerType[] = []\n\n  function haveChanged(): boolean {\n    return pluginsChanged.some((hasChanged) => hasChanged())\n  }\n\n  function hasChanged(plugin: EmblaPluginType): PluginChangedHandlerType {\n    const options = atMedia(plugin.options)\n    return (): boolean => !areEqual(options, atMedia(plugin.options))\n  }\n\n  function init(\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ): EmblaPluginsType {\n    pluginsChanged = plugins.map(hasChanged)\n    activePlugins = plugins.filter((plugin) => atMedia(plugin.options).active)\n    activePlugins.forEach((plugin) => plugin.init(embla))\n\n    return plugins.reduce((map, plugin) => {\n      return Object.assign(map, { [plugin.name]: plugin })\n    }, {})\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy,\n    haveChanged,\n  }\n  return self\n}\n","type CallbackType = (evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventHandlerType = {\n  emit: (evt: EmblaEventType) => EventHandlerType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n}\n\nexport function EventHandler(): EventHandlerType {\n  const listeners: ListenersType = {}\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventHandlerType {\n    getListeners(evt).forEach((e) => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventHandlerType = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import EmblaCarousel, { EmblaPluginType } from 'embla-carousel'\n\nexport function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function sortAndMapPluginToOptions(\n  plugins: EmblaPluginType[],\n): EmblaPluginType['options'][] {\n  return plugins\n    .concat()\n    .sort((a, b) => (a.name > b.name ? 1 : -1))\n    .map((plugin) => plugin.options)\n}\n\nexport function arePluginsEqual(\n  pluginsA: EmblaPluginType[],\n  pluginsB: EmblaPluginType[],\n): boolean {\n  if (pluginsA.length !== pluginsB.length) return false\n\n  const { areEqual } = EmblaCarousel.optionsHandler()\n  const optionsA = sortAndMapPluginToOptions(pluginsA)\n  const optionsB = sortAndMapPluginToOptions(pluginsB)\n\n  return optionsA.every((optionA, index) => {\n    const optionB = optionsB[index]\n    return areEqual(optionA, optionB)\n  })\n}\n","import { useRef, useEffect, useState, useCallback } from 'react'\nimport { arePluginsEqual, canUseDOM } from './utils'\nimport EmblaCarousel, {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType,\n} from 'embla-carousel'\n\ntype EmblaViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null,\n) => void\n\nexport type UseEmblaCarouselType = [\n  EmblaViewportRefType,\n  EmblaCarouselType | undefined,\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n  plugins: EmblaPluginType[] = [],\n): UseEmblaCarouselType {\n  const optionsHandler = useRef(EmblaCarousel.optionsHandler())\n  const storedOptions = useRef(options)\n  const storedPlugins = useRef(plugins)\n  const [embla, setEmbla] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n\n  const reInit = useCallback(() => {\n    if (embla) embla.reInit(storedOptions.current, storedPlugins.current)\n  }, [embla])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions\n      const newEmbla = EmblaCarousel(\n        viewport,\n        storedOptions.current,\n        storedPlugins.current,\n      )\n      setEmbla(newEmbla)\n      return () => newEmbla.destroy()\n    } else {\n      setEmbla(undefined)\n    }\n  }, [viewport, setEmbla])\n\n  useEffect(() => {\n    if (optionsHandler.current.areEqual(storedOptions.current, options)) return\n\n    storedOptions.current = options\n    reInit()\n  }, [options, reInit])\n\n  useEffect(() => {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return\n\n    storedPlugins.current = plugins\n    reInit()\n  }, [plugins, reInit])\n\n  return [<EmblaViewportRefType>setViewport, embla]\n}\n\nuseEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\n\nexport default useEmblaCarousel\n","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}"],"names":["isNumber","subject","isObject","Object","prototype","toString","call","isRecord","Array","isArray","mathAbs","n","Math","abs","mathSign","deltaAbs","valueB","valueA","arrayKeys","array","objectKeys","map","Number","arrayLast","arrayLastIndex","max","length","object","keys","objectsMergeDeep","objectA","objectB","reduce","mergedObjects","currentObject","forEach","key","areObjects","objectsAreEqual","objectAKeys","objectBKeys","every","concat","Alignment","align","viewSize","predefined","start","center","end","measure","Limit","min","reachedMin","reachedMax","reachedAny","constrain","removeOffset","ceil","Counter","loop","loopEnd","counter","withinLimit","get","set","self","add","clone","EventStore","listeners","node","type","handler","options","passive","addEventListener","push","removeEventListener","removeAll","filter","remove","Vector1D","value","vector","divide","readNumber","multiply","normalize","subtract","DragHandler","axis","direction","rootNode","target","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","index","eventHandler","percentOfView","dragFree","skipSnaps","crossAxis","focusNodes","nonPassiveEvent","dragStartPoint","activationEvents","interactionEvents","dragThreshold","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","baseMass","startScroll","startCross","pointerIsDown","preventScroll","preventClick","isMouse","down","evt","isTouchEvent","button","name","nodeName","indexOf","isFocusNode","isMoving","clearPreventClick","pointerDown","useBaseMass","useSpeed","document","move","up","addInteractionEvents","readPoint","emit","cancelable","lastScroll","lastCross","diffScroll","diffCross","diff","pointerMove","apply","preventDefault","targetChanged","byDistance","rawForce","pointerUp","force","next","isEdge","baseForce","distance","byIndex","allowedForce","forceFactor","factorAbs","isVigorous","isBelowThreshold","speed","mass","useMass","click","stopPropagation","addActivationEvents","clickAllowed","removeAllEvents","ScrollBody","roundToTwoDecimals","decimalPoints","pow","round","roundToDecimals","velocity","acceleration","attraction","attractionDirection","seek","iStart","oStart","magnitude","settle","hasSettled","update","useBaseSpeed","ScrollBounds","limit","pullBackThreshold","edgeOffsetTolerance","maxFriction","disabled","edge","diffToEdge","diffToTarget","friction","toggleActive","active","ScrollContain","contentSize","snapsAligned","containScroll","scrollBounds","snapsBounded","snapsContained","startSnap","endSnap","lastIndexOf","findDuplicates","slice","measureContained","ScrollLooper","vectors","shouldLoop","loopDistance","v","ScrollProgress","scrollLength","ScrollTarget","scrollSnaps","targetVector","minDistance","distances","sort","a","b","shortcut","targets","t","snap","scrollSnap","diffToSnap","i","d1","d2","findTargetSnap","targetSnapDistance","reachedBound","Translate","container","translate","scroll","containerStyle","style","clear","transform","getAttribute","removeAttribute","to","SlideLooper","slideSizesWithGaps","slidesInView","slides","ascItems","descItems","reverse","loopPoints","gap","findLoopPoints","slidesInGap","startPoints","endPoints","removeSlideSizes","indexes","from","isStartEdge","offset","slideBounds","findSlideBounds","initial","altered","point","shift","canLoop","_a","loopPoint","SlidesInView","slideSizes","snaps","inViewThreshold","roundingSafety","cachedOffsets","cachedBounds","offsets","threshold","slideOffsets","slideThresholds","slideThreshold","slideSize","findSlideThresholds","list","bounds","check","limitedLocation","slideBound","SlidesToScroll","slidesToScroll","groupByNumber","groupSlides","groupSize","byNumber","groupSizes","chunkSize","s","bySize","Engine","root","scrollAxis","contentDirection","startIndex","containerRect","getBoundingClientRect","slideRects","slide","sign","Direction","cross","startEdge","endEdge","measureSize","rect","width","height","Axis","PercentOfView","alignment","containSnaps","readEdgeGap","withEdgeGap","startGap","slideRect","measureStartGap","endGap","window","getComputedStyle","parseFloat","getPropertyValue","measureEndGap","rects","isFirst","isLast","SlideSizes","alignments","containedEndSnap","g","groupedSnaps","measureAligned","ScrollSnaps","measureLimit","ScrollLimit","indexPrevious","slideIndexes","callback","animationFrame","ifAnimating","cb","requestAnimationFrame","proceed","stop","cancelAnimationFrame","Animation","engine","dragHandler","settled","scrollLooper","slideLooper","startLocation","indexCurrent","distanceDiff","indexDiff","targetIndex","ScrollTo","startEvent","lastEvent","logInterval","TouchEvent","readTime","timeStamp","evtAxis","property","coord","touches","expired","diffDrag","diffTime","DragTracker","eventStore","scrollProgress","defaultOptions","breakpoints","draggable","OptionsHandler","merge","optionsA","optionsB","areEqual","JSON","stringify","atMedia","optionsAtMedia","matchedMediaOptions","media","matchMedia","matches","mediaOption","EmblaCarousel","nodes","userOptions","userPlugins","pluginApis","resizeHandlers","optionsHandler","pluginsHandler","activePlugins","pluginsChanged","hasChanged","plugin","init","plugins","embla","assign","destroy","haveChanged","some","PluginsHandler","getListeners","e","off","on","EventHandler","reInit","reActivate","destroyed","optionsBase","globalOptions","pluginList","rootSize","activate","withOptions","withPlugins","providedContainer","providedSlides","children","storeElements","deActivate","offsetParent","selectedScrollSnap","jump","canScrollNext","canScrollPrev","containerNode","internalEngine","previousScrollSnap","scrollNext","scrollPrev","scrollSnapList","slideNodes","slidesNotInView","inView","newOptions","optionsChanged","newRootSize","rootSizeChanged","setTimeout","sortAndMapPluginToOptions","useEmblaCarousel","useRef","storedOptions","storedPlugins","useState","setEmbla","viewport","setViewport","useCallback","current","useEffect","createElement","newEmbla_1","undefined","pluginsA","pluginsB","optionA","optionB","arePluginsEqual","_defineProperty","obj","defineProperty","enumerable","configurable","writable","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","sym","getOwnPropertyDescriptor","_objectSpread2","arguments","source","getOwnPropertyDescriptors","defineProperties"],"sourceRoot":""}